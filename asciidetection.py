import os
from init import read, write, linecount, readall, writelist  # type: ignore
import time
import sys 
import subprocess
from stringcolor import cs
def asciiread(input):
    z = readall(input)
    find = []
    for x in range(19, 59):
        find.append(z[x])
    find = ''.join(find)
    return find
#sets up ARGS,so they aren't manditory when executing.
skim = []
acceptedterms = ['gen', 'exists']
#defines the generate function, creates ascii with file associations.
def gen(arg1, arg2, arg3):
    if arg1 not in acceptedterms:
        return exit(cs("Error: arg1 must be gen or exists", "#F93148"))
    elif os.path.exists(arg2) == False:
        return exit(cs('ARG2 MUST EXIST', '#F93148'))
    if arg1 == 'exists':
        if os.path.exists(f'{arg2}/html') == False:
            return exit(cs(f'-EXISTS USED AND {arg2}/html DOES NOT EXIST', 'F93148'))
    elif arg1 == 'gen':
        p = subprocess.Popen(['bash', 'ascii.sh', arg2, arg3])
        p.wait()
    htmlindex = os.listdir(f'{arg2}/html')
    htmlindex.sort(key=lambda x: int(x.partition('.')[0].partition('k')[2]))
    for x in range(0, len(htmlindex)):
        inf = f'{arg2}/html/{htmlindex[x]}'
        try:
            find = asciiread(inf)
            #possible wrong exception
        except IndexError:
            continue
        if not find:
            continue
        elif len(find) != 4000:
            continue
        skim.append((inf, find))
    #creates a list of ascii and their respective fil associations.
    return

def asciimain(arg2):
    #this works via ths command
    #"jp2a {inf} --size=100x40 --colors  --chars=01 
    #it outputs a 0 or a 1 depending on light level.
    boop = []
    tot1 = []
    #Ths imports the 1-12-ids generated by make.py to boop[]
    for v in range(0, 12):
        test = read(v, 'id/uni.txt')
        boop.append((v+1, []))
        z = test.count(',')+1
        for x in range(0, z):
            if x == z-1:
                boop[v][1].append(test.partition(',')[0][:-1])
            else:
                boop[v][1].append(test.partition(',')[0][1:])
            test = test.partition(',')[2]

    new2 = []
    guess = []
    tot = []
    #this is where the magic happens.
    #this classifies all ranks.
    for xz in range(0, len(skim)):
        new2 = []
        guess = []
        guesstot = []
        for xV in range(0, len(boop)):
            #this cycles through the various ids and reads it from skim's import
            for x in boop[xV][1]:
                new2.append(skim[xz][1][int(x)])
            guess.append(''.join(new2).count('1'))
            new2 = []
        guesstot = []
        #this creates a number of correct guesses per boop entry
        for x in range(0, len(guess)):
            guesstot.append((boop[x][0], (len(boop[x][1]) - guess[x])))
        #sorts guesstot by number of correct guesses from least to most
        #((less is more, so really most to least))
        guesstot.sort(key=lambda x: x[1])
        #if it is more incorrect than the > (17) it skips
        #lower is less tolerant.
        #17 is very tolerant, a standard deviation is like 5
        if guesstot[0][1] > 17:
            if not tot:
                continue
            #if tot is false skips the first one  given.
            #else it just gives the most recent one and continues
            tot1.append(skim[xz][0])
            tot.append((tot[-1]))
            continue
        tot.append((guesstot[0][0], guesstot[1][1]))
    #note, TOT is comprised of the rank (tot[x][0]) and the 2nd most liklies
    #score, tot[x][1]. E.G. (1, 67), 1 being score, 67 being x+1[1]
    tot2 = []
    error = 0
    state = 1
    lastgood = 0
    print(tot)
    #here is the filtering list, rebuilding from tots literal start.
    for x in range(0, len(tot)):
        #factors for the skip
        x = x+error
        try:
            #if the next one isn't at least 34 wrong, skip
            #higher number is less tolerant.
            if tot[x][1] < 34:
                if lastgood == 0:
                    if x == 0:
                        #does this loop at start until broken
                        print(state)
                        state = 2
                        continue
                    if state == 2:
                        #at start, tot2 doesn't get appeneded until
                        #the next likely number is less than 34.
                        #this is to prevent 1s at the start of score rec
                        if tot[x][1] < 34:
                            print(tot[x][1])
                            print('boop')
                            continue
                        else:
                            print(tot[x][1])
                            state = 1
                    #rollback.
                    #lastgood == the last good X encase a spiral happens.
                    tot2.append(tot[x-1][0])
                    lastgood = x-1
                else:
                    tot2.append(tot[lastgood][0])
            else:
                tot2.append(tot[x][0])
                lastgood = x
        except Exception:
            break
    print(tot2)    
    print(arg2)
    writelist(tot2, f"{arg2}/rank.txt")
    write(tot2[-1], 2, f"{arg2}/meta.txt")
    f = float(sum(tot2)/len(tot2))
    write(f, 3, f"{arg2}/meta.txt")
    write(min(tot2), 4, f"{arg2}/meta.txt")
    write(max(tot2), 5, f'{arg2}/meta.txt')


    #for x in trange(0, len(new)):
    #   new[x].pop(0)
    #  new2.append(new[x][0])
    # 3 = final rank entry
    #4 = averege rank
    #5 = lowest place
    #6 = highest place
if __name__ == '__main__':
    exit("Not currently supported outsided of module form :)") 
    #try:
    #    arg1 = sys.argv[1]
    #except: 
    #    arg1 = '1'
    #try:
    #    arg2 = sys.argv[2]
    #    if arg2[-1:] == '/':
    #        arg2 = arg2[0:-1]
    #except:
    #    arg2 = '1'
    #try:
    #    arg3 = sys.argv[3]
    #except:
    #    arg3 = '1'
    #gen(arg1, arg2, arg3)
    #asciimain(arg2)
